---
## Author 
  author:
    name: Колесников Михаил Александрович
    email: 1032256500@pfur.ru
    affiliation:
      - name: Российский университет дружбы народов


## Title
  title: "Отчет по лабораторной работе №9\n\nНомер студенческого билета: 1032256500"
  license: "CC BY"

## Format
  format:
    pdf:
      pdf-engine: xelatex
      mainfont: "Liberation Serif"
  lang: ru
  header-includes:
    - \usepackage{fontspec}
---

# Цель работы
Познакомиться с понятием дебаг, попробовать проследить за тем, как выполняется команда и на основе этого выяснить, где ошибка

# Выполнение лабораторной работы

   1) Создаем папку **lab09**

![Создание папки для выполнения лабораторной работы №9](image/фото1_лаб9.png){#fig:1 width=70%}

   2) Создаем файл **lab09-1.asm**

![Создание файла](image/фото2_лаб9.png){#fig:2 width=70%}

   3) Записываем в файл **lab09-1.asm** код, который нам дали в лабораторной работе

![Запись кода из лабораторной работы](image/фото3_лаб9.png){#fig:3 width=70%}

   4) Компилируем и запускаем исполняемый файл lab09-1

![Компилируем и запускаем файл](image/фото4_лаб9.png){#fig:4 width=70%}

   5) Редактируем файл **lab09-1.asm** так, чтобы код удовлетворял заданию

![Редактируем файл ](image/фото5_лаб9.png){#fig:5 width=70%}

   6) Компилируем и запускаем отредактированный файл **lab09-1.asm**

![Компилируем и запускаем отредактированный файл](image/фото6_лаб9.png){#fig:6 width=70%}

   7) Создаем файл **lab09-2.asm**

![Создание файла **lab09-2.asm**](image/фото7_лаб9.png){#fig:7 width=70%}

   8) Записываем в файл код, который нам дали в лабораторной работе

![Запись кода из лабораторной работы](image/фото8_лаб9.png){#fig:8 width=70%}

   9) Компилируем файл и запускаем его в отладчике **GDB**

![Компилируем и запускаем файл в отладчике](image/фото9_лаб9.png){#fig:9 width=70%}

   10) Прописываем команду **run**, чтобы запустить исполняемый файл

![Запускаем исполняемый файл](image/фото10_лаб9.png){#fig:10 width=70%}

   11) Ставим точку **останова** на _start и снова запускаем файл

![Ставим точку останова и запускаем файл](image/фото11_лаб9.png){#fig:11 width=70%}

   12) Выводим дизассемблирование программы 1-ым способом

![Вывод дизассемблирование программы. Первый способ](image/фото12_лаб9.png){#fig:12 width=70%}

   13) Выводим дизассемблирование программы 2-ым способом

![Вывод дизассемблирование программы. Второй способ](image/фото13_лаб9.png){#fig:13 width=70%}

   Различия:
   1) Порядок операндов
   - AT&T: операция источник, назначение
    Пример: mov $5, %eax (значение 5 перемещается в регистр eax)
   - Intel: операция назначение, источник
    Пример: mov eax, 5 (регистр eax получает значение 5)

   2) Обозначение регистров
   - AT&T: перед именем регистра ставится символ %
    Пример: %eax, %ebx, %ecx
   - Intel: регистры указываются без специальных символов
    Пример: eax, ebx, ecx
    
   3) Обозначение немедленных значений (констант)
   - AT&T: перед числом ставится символ $
    Пример: $5, $0x10
   - Intel: числа указываются без специальных символов
    Пример: 5, 0x10

   14) Прописываем команды **layout asm** и **layout regs**

![Прописываем команды](image/фото14_лаб9.png){#fig:14 width=70%}

   15) С помощью команды **info breakpoints** узнаем обо всех точках **останова**
   
![Выводим информацию обо всех точках останова](image/фото15_лаб9.png){#fig:15 width=70%}

   16) Установим еще одну точку останова по адресу с помощью команды **break**

![Устанавливаем еще одну точку останова](image/фото16_лаб9.png){#fig:16 width=70%}

   17) Выведем информацию о новых точках

![Вывод информации о точках останова](image/фото17_лаб9.png){#fig:17 width=70%}

   18) Посмотрим содержимое ячеек памяти и регистров

![Просмотр значений ячеек и регистров](image/фото18_лаб9.png){#fig:18 width=70%}

   19) Посмотрим значение переменной **msg1**

![Просмотр значения переменной **msg1**](image/фото19_лаб9.png){#fig:19 width=70%}

   20) Посмотрим на значение переменной **msg2**, используя ее адрес

![Просмотр значения переменной **msg2**](image/фото20_лаб9.png){#fig:20 width=70%}

   21) Заменим первый символ значения переменной **msg1** и выведем ее содержимое

![Замена первого символа переменной **msg1**](image/фото21_лаб9.png){#fig:21 width=70%}

   22) Заменим первый символ значения переменной **msg2** и выведем ее содержимое

![Замена первого символа переменной **msg2**](image/фото22_лаб9.png){#fig:22 width=70%}


   23) Заменим значение регистра **ebx** и выведем содержимое

![Замена значения регистра **ebx**](image/фото23_лаб9.png){#fig:23 width=70%}

   24) Скопируем содержимое файла **lab08-2.asm** в **lab09-3.asm**

![Копирование содержимого файла](image/фото24_лаб9.png){#fig:24 width=70%}

   25) Скомпилируем и запустим файл **lab09-3.asm** в GDB, передав аргументы

![Компилируем файл](image/фото25_лаб9.png){#fig:25 width=70%}

   26) Ставим точку **останова** и запускаем файл
   
![Ставим точку останова и запускаем файл](image/фото26_лаб9.png){#fig:26 width=70%}

   27) Выведем количество аргументов

![Вывод количества аргументов](image/фото27_лаб9.png){#fig:27 width=70%}

   28) Выведем значение каждого аргумента
   
![Вывод значений аргументов](image/фото28_лаб9.png){#fig:28 width=70%}

Шаг изменения адреса равен 4 байтам потому, что в 32-битной архитектуре x86 (которая используется в лабораторной работе с флагом -m elf_i386) размер указателя составляет 4 байта (32 бита).

   29) Создадим файл **task1.asm**

![Создание файла](image/фото29_лаб9.png){#fig:29 width=70%}

**Задания для самостоятельной работы**

   30) Решим первое задание из лабораторной работы

![Решение первого задания](image/фото30_лаб9.png){#fig:30 width=70%}

   31) Скомпилируем и запустим исполняемый файл
   
![Компилирование и запуск файла](image/фото31_лаб9.png){#fig:31 width=70%}

   32) Создаем файл **task2.asm**

![Создание файла](image/фото32_лаб9.png){#fig:32 width=70%}

   33) Запишем в него код, который нам дали в лабораторной работе

![Запись кода из лабораторной работы](image/фото33_лаб9.png){#fig:33 width=70%}

   34) Скомпилируем и запустим файл в **GDB**

![Компилируем и запускаем файл](image/фото34_лаб9.png){#fig:34 width=70%}

   35) Ставим точку **останова** и запускаем файл

![Запускаем файл и ставим точку останова](image/фото35_лаб9.png){#fig:35 width=70%}

   36) Выводим дизассемблированый код файла

![Выводим дизассемблированый код](image/фото36_лаб9.png){#fig:36 width=70%}

   37) Выполняем одну инструкцию и выводим информацию о регистрах
   
![Выполняем одну инструкцию и выводим информацию о регистрах](image/фото37_лаб9.png){#fig:37 width=70%}

   38) Выводим текущую инструкцию

![Выводим текущую инструкцию](image/фото38_лаб9.png){#fig:38 width=70%}

   39) Продолжаем выполнение

![С помощью команды **continue** продолжаем выполнение](image/фото39_лаб9.png){#fig:39 width=70%}

   40) Выходим из режима GDB

![Выходим из режима GDB](image/фото40_лаб9.png){#fig:40 width=70%}

   41) Прописываем, какие ошибки есть в файле

![Обозначаем ошибки](image/фото41_лаб9.png){#fig:41 width=70%}

   42) Исправляем ошибки, чтобы код соответствовал условию задания

![Выводим текущую инструкцию](image/фото42_лаб9.png){#fig:42 width=70%}

   43) Компилируем и запускаем файл

![Компилируем и запускаем файл](image/фото43_лаб9.png){#fig:43 width=70%}



# Выводы

Мы познакомились с GDB  и научились находить ошибки в коде при выполнении программы

# Список литературы{.unnumbered}

::: {#refs}
:::
